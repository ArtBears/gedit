#!/bin/bash

pushd $(dirname "$0") > /dev/null
D=$(pwd -P)
popd > /dev/null

ME="$0"
BUNDLE="$D/gedit.app"

function do_strip {
	tp=$(file -b --mime-type "$1")

	if [ "$tp" != "application/octet-stream" ]; then
		return
	fi

	name=$(mktemp -t bundle)
	st=$(stat -f %p "$1")

	strip -o "$name" -S "$1"
	mv -f "$name" "$1"

	chmod "$st" "$1"
	chmod u+w "$1"
}

function make_help_usage() {
	echo "[-f]"
}

function make_help_short() {
	echo "Make the gedit.app bundle"
}

function build_gtk_mac_bundler() {
	b="$D/../build/build"
	lbin=$("$b" env local-bin)

	if [ -x "$lbin/gtk-mac-bundler" ]; then
		return
	fi

	echo "Installing gtk-mac-bundler..."

	home=$("$b" env home)
	sbin="$home/source"

	mkdir -p "$sbin"

	(
		cd "$sbin"

		if [ ! -d gtk-mac-bundler ]; then
			git clone https://github.com/jessevdk/gtk-mac-bundler || exit 1
		fi

		(
			cd gtk-mac-bundler
			git checkout -b stable f1a829521fabda2266f346dfe86bf09c9401f87d || exit 1
			HOME="$home" make install
		) || exit 1
	) || exit 1
}

function cmd_make() {
	build_gtk_mac_bundler

	if [ -d "$BUNDLE" ] && [ "$1x" = "-fx" ]; then
		rm -rf "$BUNDLE"
	fi

	b="$D/../build/build"

	# No idea why it's not writable, but we need it to be so that install_name_tool
	# can change the link paths
	inst=$("$b" env inst)
	chmod u+w "$inst/lib/libpython3.3m.dylib"

	if [ ! -d "$BUNDLE" ]; then
		lbin=$("$b" env local-bin)

		echo "Generating bundle from gedit.bundle specification..."
	    "$b" run "$lbin/gtk-mac-bundler" "$D/data/gedit.bundle" || exit 1

	    mv "$D/data/gedit.app" "$BUNDLE"
	else
		echo "$BUNDLE bundle already exists, only stripping it..."
	fi

	echo "Removing unneeded files from bundle"

	# Remove pyc and pyo files
	for i in $(find "$BUNDLE/Contents/Resources/lib/python3"* -type f -regex '.*\.py[oc]' 2>/dev/null); do
	    rm -f "$i"
	done

	echo "Strip debug symbols from bundle binaries"

	# Strip debug symbols from libraries/modules
	for i in $(find -E "$BUNDLE/Contents/Resources" -type f -regex '.*\.(so|dylib)$' 2>/dev/null); do
	    do_strip "$i"
	done

	# Strip debug symbols from binaries
	for i in $(find "$BUNDLE/Contents/Resources/bin" -type f 2>/dev/null); do
	    if [ -x "$i" ]; then
	        do_strip "$i"
	    fi
	done

	# Strip debug symbols from main binary
	do_strip "$BUNDLE/Contents/MacOS/gedit-bin"
}

function help_help_short() {
	echo "Shows this help message"
}

function cmd_help() {
	if [ -z "$1" ]; then
		echo "Usage: $ME [command]"
		echo ""
		echo "Available commands:"
		echo ""

		for cmd in "${commands[@]}"; do
			printf "  \033[1m$cmd\x1B[0m "

			l=${#cmd}
			let d="$commandsmaxlen - $l + 1"

			printf "%${d}s" ""
			echo -n "- "

			if [[ $(type -t "${cmd}_help_short") = "function" ]]; then
				"${cmd}_help_short"
			else
				echo ""
			fi
		done

		echo ""
	else
		cmd="cmd_$1"

		if [[ $(type -t "$cmd") != "function" ]]; then
			printf "Invalid command \033[1m$1\033[0m, available commands are: $cmds\n"
			exit 1
		fi

		printf "Usage: $ME \033[1m$1\033[0m "

		if [[ $(type -t "$1_help_usage") = "function" ]]; then
			"$1_help_usage"
		else
			echo ""
		fi

		echo ""

		if [[ $(type -t "$1_help_long") != "function" ]]; then
			"$1_help_short"
		else
			"$1_help_long"
		fi
	fi
}

commands=()
commandsmaxlen=0

while read line
do
	cmd=${line#declare -f }

	if [[ "$cmd" = cmd_* ]]; then
		cname=${cmd#cmd_}

		commands+=($cname)

		l=${#cname}

		if [[ $l > $commandsmaxlen ]]; then
			commandsmaxlen=$l
		fi
	fi
done < <(declare -F)

cmds=$(printf ", \033[1m%s\033[0m" "${commands[@]}")
cmds=${cmds:2}

if [ -z "$1" ]; then
	cmd_help
	exit 0
fi

cmd="cmd_$1"

if [[ $(type -t "$cmd") != "function" ]]; then
	printf "Invalid command $1, available commands are: $cmds\n"
	exit 1
fi

shift 1
"$cmd" "$@"
